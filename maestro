#include <LiquidCrystal_I2C.h>
#include <Wire.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

#define I2C_ADDR    0x27;
#define LCD_COLUMNS 16;
#define LCD_LINES   2;

  int BPMvalue = 0;
  int SVvalue = 0;
  int PSvalue = 0;
  int PDvalue = 0;
  const long interval = 2000;  // interval at which to blink (milliseconds)
  unsigned long previousMillis = 0;
  
  typedef enum estados {s0, s1, s2, s3, s4, s5, s6, s7, s8, s9} estados;
  estados estadoActual = s0;
  estados estadoFuturo = s0;


void setup() {
  lcd.begin(16, 2);
  lcd.init();
  lcd.backlight();
  pinMode(13, OUTPUT);
  pinMode(12, OUTPUT);
  pinMode(11, OUTPUT);
  pinMode(10, OUTPUT);
  pinMode(9, OUTPUT);
}

void loop() { //Aquí comienzan las transiciones de estado


  int CO = (BPMvalue)*(SVvalue);
  int Pp = (PSvalue) - (PDvalue);
  int Pm = (PDvalue) + ((Pp)/3);

  switch (estadoActual) {
    case s0:
      //Se muestra el mensaje en la LCD para indicar qué variable se está midiendo
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Leyendo pulso: ");
      delay(5000); //delay de 5000 ms
      BPMvalue = analogRead(A0); //Aquí se lee el input del sensor de BPM
        BPMvalue = map(BPMvalue, 0, 1023, 80, 260);
      lcd.clear();
      lcd.setCursor (0, 0);
      lcd.print("Pulso Registrado");
      lcd.setCursor (0, 1);
      lcd.print(BPMvalue);
      delay(5000);
      lcd.clear;
      if(BPMvalue >= 220){
          estadoFuturo = s2;
      }else{
        estadoFuturo = s1;
      }
      break;
      
    case s1:
      //Se muestra el mensaje en la LCD para indicar qué variable se está midiendo
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Leyendo Stroke: ");
      lcd.setCursor (0 ,1);
      lcd.print("Volume: ");
      delay(5000); //delay de 5000 ms
      SVvalue = analogRead(A1); //Aquí se lee el input del sensor de Stroke Volume
      SVvalue = map(SVvalue, 0, 1023, 40, 100);
      lcd.clear();
      lcd.setCursor (0, 0);
      lcd.print("SV Registrado");
      lcd.setCursor (0, 1);
      lcd.print(SVvalue);
      delay(5000);
      lcd.clear;
      if(SVvalue >= 60){
        estadoFuturo = s3;
      } else {
        estadoFuturo = s4;
      } break;

    case s2:
      estadoFuturo = s0;
      break;      

    case s3:
       //Se muestra el mensaje en la LCD para indicar qué variable se está midiendo
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Leyendo Presion: ");
      lcd.setCursor (0 ,1);
      lcd.print("Sistolica: ");
      delay(5000); //delay de 5000 ms
      PSvalue = analogRead(A2); //Aquí se lee el input del sensor de Presión sistólica
      PSvalue = map(PSvalue, 0, 1023, 90, 130);
      lcd.clear();
      lcd.setCursor (0, 0);
      lcd.print("PS Registrado");
      lcd.setCursor (0, 1);
      lcd.print(PSvalue);
      delay(5000);
      lcd.clear;
      if (PSvalue >= 100){
        estadoFuturo = s5;
      }  
      else {
        estadoFuturo = s6;
      }break;

      case s4:
        estadoFuturo = s0;
        break;
      case s5:
       //Se muestra el mensaje en la LCD para indicar qué variable se está midiendo
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Leyendo Presion: ");
      lcd.setCursor (0 ,1);
      lcd.print("Diastolica: ");
      delay(5000); //delay de 5000 ms
      PDvalue = analogRead(A3);//Aquí se lee el input del sensor de Presión diastólica
      PDvalue = map(PDvalue, 0, 1023, 60, 90);
      lcd.clear();
      lcd.setCursor (0, 0);
      lcd.print("PD Registrado");
      lcd.setCursor (0, 1);
      lcd.print(PSvalue);
      delay(5000);
      lcd.clear;
      if (PDvalue >= 80){
        estadoFuturo = s7;
      } else{
        estadoFuturo = s8;
      }break;

      case s6:
       estadoFuturo = s0;
       break;

      case s7:
        estadoFuturo = s0;

      case s8:
        estadoFuturo = s0;
        break;
        }

  switch (estadoActual){
    case s0:
      digitalWrite(13, LOW);
      digitalWrite(12, LOW);
      digitalWrite(11, LOW);
      digitalWrite(10, LOW);
      break;

    case s1:
      digitalWrite(13, LOW);
      digitalWrite(12, LOW);
      digitalWrite(11, LOW);
      digitalWrite(10, LOW);
      //buzzer pos feedback  //lcd pos feedback
      break;

    case s2:
      digitalWrite(13, HIGH); 
      digitalWrite(12, LOW);
      digitalWrite(11, LOW);
      digitalWrite(10, LOW);
      break;

    case s3:
      digitalWrite(13, LOW);
      digitalWrite(12, LOW);
      digitalWrite(11, LOW);
      digitalWrite(10, LOW);
      break;

    case s4:
      digitalWrite(13, LOW);
      digitalWrite(12, HIGH);
      digitalWrite(11, LOW);
      digitalWrite(10, LOW);
      break;

    case s5:
      digitalWrite(13, LOW);
      digitalWrite(12, LOW);
      digitalWrite(11, LOW);
      digitalWrite(10, LOW);
      break;

    case s6:
      digitalWrite(13, LOW);
      digitalWrite(12, LOW);
      digitalWrite(11, HIGH);
      digitalWrite(10, LOW);

      //buzzer neg feedback  //lcd neg feedback
      break;

    case s7:  //TERMINADO
      digitalWrite(13, LOW);
      digitalWrite(12, LOW);
      digitalWrite(11, LOW);
      digitalWrite(10, LOW);
      break;

    case s8:
      digitalWrite(13, LOW);
      digitalWrite(12, LOW);
      digitalWrite(11, LOW);
      digitalWrite(10, HIGH);
      break;
  }
  unsigned long currentMillis = millis();
if (currentMillis - previousMillis >=
interval) {
estadoActual = estadoFuturo;
previousMillis = currentMillis;
}
}
